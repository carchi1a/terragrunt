<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>02_features/execute-terraform-commands-on-multiple-units-at-once.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<hr />

<p>layout: collection-browser-doc
title: Execute OpenTofu/Terraform commands on multiple units at once
category: features
categories<em>url: features
excerpt: Learn how to avoid tedious tasks of running commands on each unit separately.
tags: ["DRY", "Unit", "Modules", "Use cases", "CLI"]
order: 220
nav</em>title: Documentation</p>

<h2>nav<em>title</em>link: /docs/</h2>

<h2>Execute OpenTofu/Terraform commands on multiple units at once</h2>

<ul>
<li><a href="#execute-opentofuterraform-commands-on-multiple-units-at-once">Execute OpenTofu/Terraform commands on multiple units at once</a>
<ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#the-run-all-command">The run-all command</a></li>
<li><a href="#passing-outputs-between-units">Passing outputs between units</a></li>
<li><a href="#unapplied-dependency-and-mock-outputs">Unapplied dependency and mock outputs</a></li>
<li><a href="#dependencies-between-units">Dependencies between units</a></li>
<li><a href="#testing-multiple-units-locally">Testing multiple units locally</a></li>
<li><a href="#limiting-the-unit-execution-parallelism">Limiting the unit execution parallelism</a></li>
<li><a href="#saving-opentofuterraform-plan-output">Saving OpenTofu/Terraform plan output</a></li>
</ul></li>
</ul>

<h3>Motivation</h3>

<p>Let’s say your infrastructure is defined across multiple OpenTofu/Terraform units:</p>

<p><code>tree
root
├── backend-app
│   └── main.tf
├── frontend-app
│   └── main.tf
├── mysql
│   └── main.tf
├── redis
│   └── main.tf
└── vpc
    └── main.tf
</code></p>

<p>There is one unit to deploy a frontend-app, another to deploy a backend-app, another for the MySQL database, and so on. To deploy such an environment, you’d have to manually run <code>tofu apply</code>/<code>terraform apply</code> in each of the subfolder, wait for it to complete, and then run <code>tofu apply</code>/<code>terraform apply</code> in the next subfolder. How do you avoid this tedious and time-consuming process?</p>

<h3>The run-all command</h3>

<p>To be able to deploy multiple OpenTofu/Terraform units in a single command, add a <code>terragrunt.hcl</code> file to each unit:</p>

<p><code>tree
root
├── backend-app
│   ├── main.tf
│   └── terragrunt.hcl
├── frontend-app
│   ├── main.tf
│   └── terragrunt.hcl
├── mysql
│   ├── main.tf
│   └── terragrunt.hcl
├── redis
│   ├── main.tf
│   └── terragrunt.hcl
└── vpc
    ├── main.tf
    └── terragrunt.hcl
</code></p>

<p>Now you can go into the <code>root</code> folder and deploy all the units within it by using the <code>run-all</code> command with
<code>apply</code>:</p>

<p><code>bash
cd root
terragrunt run-all apply
</code></p>

<p>When you run this command, Terragrunt will recursively look through all the subfolders of the current working directory, find all folders with a <code>terragrunt.hcl</code> file, and run <code>terragrunt apply</code> in each of those folders concurrently.</p>

<p>Similarly, to undeploy all the OpenTofu/Terraform units, you can use the <code>run-all</code> command with <code>destroy</code>:</p>

<p><code>bash
cd root
terragrunt run-all destroy
</code></p>

<p>To see the currently applied outputs of all of the subfolders, you can use the <code>run-all</code> command with <code>output</code>:</p>

<p><code>bash
cd root
terragrunt run-all output
</code></p>

<p>Finally, if you make some changes to your project, you could evaluate the impact by using <code>run-all</code> command with <code>plan</code>:</p>

<p>Note: It is important to realize that you could get errors running <code>run-all plan</code> if you have dependencies between your
projects and some of those dependencies haven’t been applied yet.</p>

<p><em>Ex: If unit A depends on unit B and unit B hasn’t been applied yet, then run-all plan will show the plan for B, but exit with an error when trying to show the plan for A.</em></p>

<p><code>bash
cd root
terragrunt run-all plan
</code></p>

<p>If your units have dependencies between them, for example, you can’t deploy the backend-app until MySQL and redis are deployed—you’ll need to express those dependencies in your Terragrunt configuration as explained in the next section.</p>

<p>Additional note: If your units have dependencies between them, and you run a <code>terragrunt run-all destroy</code> command, Terragrunt will destroy all the units under the current working directory, <em>as well as each of the unit dependencies</em> (that is, units you depend on via <code>dependencies</code> and <code>dependency</code> blocks)! If you wish to use exclude dependencies from being destroyed, add the <code>--queue-exclude-external</code> flag, or use the <code>--queue-exclude-dir</code> once for each directory you wish to exclude.</p>

<h3>Passing outputs between units</h3>

<p>Consider the following file structure:</p>

<p><code>tree
root
├── backend-app
│   ├── main.tf
│   └── terragrunt.hcl
├── mysql
│   ├── main.tf
│   └── terragrunt.hcl
├── redis
│   ├── main.tf
│   └── terragrunt.hcl
└── vpc
    ├── main.tf
    └── terragrunt.hcl
</code></p>

<p>Suppose that you wanted to pass in the VPC ID of the VPC that is created from the <code>vpc</code> unit in the folder structure above to the <code>mysql</code> unit as an input variable. Or if you wanted to pass in the subnet IDs of the private subnet that is allocated as part of the <code>vpc</code> unit.</p>

<p>You can use the <code>dependency</code> block to extract the output variables to access another unit’s output variables in the terragrunt <code>inputs</code> attribute.</p>

<p>For example, suppose the <code>vpc</code> unit outputs the ID under the name <code>vpc_id</code>. To access that output, you would specify in <code>mysql/terragrunt.hcl</code>:</p>

<p>```hcl
dependency "vpc" {
  config_path = "../vpc"
}</p>

<p>inputs = {
  vpc<em>id = dependency.vpc.outputs.vpc</em>id
}
```</p>

<p>When you apply this unit, the output will be read from the <code>vpc</code> unit and passed in as an input to the <code>mysql</code> unit right before calling <code>tofu apply</code>/<code>terraform apply</code>.</p>

<p>You can also specify multiple <code>dependency</code> blocks to access multiple different unit output variables. For example, in the above folder structure, you might want to reference the <code>domain</code> output of the <code>redis</code> and <code>mysql</code> units for use as <code>inputs</code> in the <code>backend-app</code> unit. To access those outputs, you would specify in <code>backend-app/terragrunt.hcl</code>:</p>

<p>```hcl
dependency "mysql" {
  config_path = "../mysql"
}</p>

<p>dependency "redis" {
  config_path = "../redis"
}</p>

<p>inputs = {
  mysql<em>url = dependency.mysql.outputs.domain
  redis</em>url = dependency.redis.outputs.domain
}
```</p>

<p>Note that each <code>dependency</code> is automatically considered a dependency in Terragrunt. This means that when you run <code>run-all apply</code> on a config that has <code>dependency</code> blocks, Terragrunt will not attempt to deploy the config until all the units referenced in <code>dependency</code> blocks have been applied. So for the above example, the order for the <code>run-all apply</code> command would be:</p>

<ol>
<li><p>Deploy the VPC</p></li>
<li><p>Deploy MySQL and Redis in parallel</p></li>
<li><p>Deploy the backend-app</p></li>
</ol>

<p>If any of the units failed to deploy, then Terragrunt will not attempt to deploy the units that depend on them.</p>

<p><strong>Note</strong>: Not all blocks are able to access outputs passed by <code>dependency</code> blocks. See the section on <a href="{{site.baseurl}}/docs/getting-started/configuration/#configuration-parsing-order">Configuration parsing order</a> for more information.</p>

<h4>Unapplied dependency and mock outputs</h4>

<p>Terragrunt will return an error indicating the dependency hasn’t been applied yet if the unit referenced in a <code>dependency</code> block has not been applied yet. This is because you cannot actually fetch outputs out of an unapplied unit, even if there are no resources being created in the unit.</p>

<p>This is most problematic when running commands that do not modify state (e.g <code>run-all plan</code> and <code>run-all validate</code>) on a completely new setup where no infrastructure has been deployed. You won’t be able to <code>plan</code> or <code>validate</code> a unit if you can’t determine the <code>inputs</code>. If the unit depends on the outputs of another unit that hasn’t been applied yet, you won’t be able to compute the <code>inputs</code> unless the dependencies are all applied. However, in real life usage, you would want to run <code>run-all validate</code> or <code>run-all plan</code> on a completely new set of infrastructure.</p>

<p>To address this, you can provide mock outputs to use when a unit hasn’t been applied yet. This is configured using the <code>mock_outputs</code> attribute on the <code>dependency</code> block and it corresponds to a map that will be injected in place of the actual dependency outputs if the target config hasn’t been applied yet.</p>

<p>For example, in the previous example with a <code>mysql</code> unit and <code>vpc</code> unit, suppose you wanted to place in a temporary, dummy value for the <code>vpc_id</code> during a <code>run-all validate</code> for the <code>mysql</code> unit. You can specify in <code>mysql/terragrunt.hcl</code>:</p>

<p>```hcl
dependency "vpc" {
  config_path = "../vpc"</p>

<p>mock<em>outputs = {
    vpc</em>id = "temporary-dummy-id"
  }
}</p>

<p>inputs = {
  vpc<em>id = dependency.vpc.outputs.vpc</em>id
}
```</p>

<p>You can now run <code>validate</code> on this config before the <code>vpc</code> unit is applied because Terragrunt will use the map <code>{vpc_id = "temporary-dummy-id"}</code> as the <code>outputs</code> attribute on the dependency instead of erroring out.</p>

<p>What if you wanted to restrict this behavior to only the <code>validate</code> command? For example, you might not want to use the defaults for a <code>plan</code> operation because the plan doesn’t give you any indication of what is actually going to be created.</p>

<p>You can use the <code>mock_outputs_allowed_terraform_commands</code> attribute to indicate that the <code>mock_outputs</code> should only be used when running those OpenTofu/Terraform commands. So to restrict the <code>mock_outputs</code> to only when <code>validate</code> is being run, you can modify the above <code>terragrunt.hcl</code> file to:</p>

<p>```hcl
dependency "vpc" {
  config_path = "../vpc"</p>

<p>mock<em>outputs = {
    vpc</em>id = "temporary-dummy-id"
  }
  mock<em>outputs</em>allowed<em>terraform</em>commands = ["validate"]
}</p>

<p>inputs = {
  vpc<em>id = dependency.vpc.outputs.vpc</em>id
}
```</p>

<p>Note that indicating <code>validate</code> means that the <code>mock_outputs</code> will be used either with <code>validate</code> or with <code>run-all validate</code>.</p>

<p>You can also use <code>skip_outputs</code> on the <code>dependency</code> block to specify the dependency without pulling in the outputs:</p>

<p><code>hcl
dependency "vpc" {
  config_path = "../vpc"
  skip_outputs = true
}
</code></p>

<p>When <code>skip_outputs</code> is used with <code>mock_outputs</code>, mocked outputs will be returned without pulling in the outputs from remote states. This can be useful when you disable the backend initialization (<code>remote_state.disable_init</code>) in CI for example.</p>

<p>```hcl
dependency "vpc" {
  config<em>path = "../vpc"
  mock</em>outputs = {
    vpc_id = "temporary-dummy-id"
  }</p>

<p>skip_outputs = true
}
```</p>

<p>You can also use <code>mock_outputs_merge_strategy_with_state</code> on the <code>dependency</code> block to merge the mocked outputs and the state outputs :</p>

<p>```hcl
dependency "vpc" {
  config<em>path = "../vpc"
  mock</em>outputs = {
    vpc<em>id     = "temporary-dummy-id"
    new</em>output = "temporary-dummy-value"
  }</p>

<p>mock<em>outputs</em>merge<em>strategy</em>with_state = "shallow"
}
```</p>

<p>If the state outputs only contains <code>vpc_id</code>, this value will be preserved. And <code>new_output</code> which is not existing, the mock value will be used.</p>

<h3>Dependencies between units</h3>

<p>You can also specify dependencies explicitly. Consider the following file structure:</p>

<p><code>tree
root
├── backend-app
│   ├── main.tf
│   └── terragrunt.hcl
├── frontend-app
│   ├── main.tf
│   └── terragrunt.hcl
├── mysql
│   ├── main.tf
│   └── terragrunt.hcl
├── redis
│   ├── main.tf
│   └── terragrunt.hcl
└── vpc
    ├── main.tf
    └── terragrunt.hcl
</code></p>

<p>Let’s assume you have the following dependencies between OpenTofu/Terraform units:</p>

<ul>
<li><p><code>backend-app</code> depends on <code>mysql</code>, <code>redis</code>, and <code>vpc</code></p></li>
<li><p><code>frontend-app</code> depends on <code>backend-app</code> and <code>vpc</code></p></li>
<li><p><code>mysql</code> depends on <code>vpc</code></p></li>
<li><p><code>redis</code> depends on <code>vpc</code></p></li>
<li><p><code>vpc</code> has no dependencies</p></li>
</ul>

<p>You can express these dependencies in your <code>terragrunt.hcl</code> config files using a <code>dependencies</code> block. For example, in <code>backend-app/terragrunt.hcl</code> you would specify:</p>

<p><code>hcl
dependencies {
  paths = ["../vpc", "../mysql", "../redis"]
}
</code></p>

<p>Similarly, in <code>frontend-app/terragrunt.hcl</code>, you would specify:</p>

<p><code>hcl
dependencies {
  paths = ["../vpc", "../backend-app"]
}
</code></p>

<p>Once you’ve specified the dependencies in each <code>terragrunt.hcl</code> file, when you run the <code>terragrunt run-all apply</code> or <code>terragrunt run-all destroy</code>, Terragrunt will ensure that the dependencies are applied or destroyed, respectively, in the correct order. For the example at the start of this section, the order for the <code>run-all apply</code> command would be:</p>

<ol>
<li><p>Deploy the VPC</p></li>
<li><p>Deploy MySQL and Redis in parallel</p></li>
<li><p>Deploy the backend-app</p></li>
<li><p>Deploy the frontend-app</p></li>
</ol>

<p>If any of the units fail to deploy, then Terragrunt will not attempt to deploy the units that depend on them. Once you’ve fixed the error, it’s usually safe to re-run the <code>run-all apply</code> or <code>run-all destroy</code> command again, since it’ll be a no-op for the units that already deployed successfully, and should only affect the ones that had an error the last time around.</p>

<p>To check all of your dependencies and validate the code in them, you can use the <code>run-all validate</code> command.</p>

<p>To check the dependency graph you can use the <code>graph-dependencies</code> command (similar to the <code>terraform graph</code> command),
the graph is output in DOT format The typical program that can read this format is GraphViz, but many web services are also available to read this format.</p>

<p><code>bash
terragrunt graph-dependencies | dot -Tsvg &gt; graph.svg
</code></p>

<p>In the example above it'll generate this graph</p>

<p><img src="{{site.baseurl}}/assets/img/collections/documentation/graph.png" alt="terragrunt graph-dependencies" title="" /></p>

<p>Note that this graph shows the dependency relationship in the direction of the arrow (top down), however terragrunt will run the action
in reverse order (bottom up)</p>

<p><strong>Note:</strong> During execution of <code>destroy</code> command, Terragrunt will try to find all dependent units and show a confirmation prompt with a list of all detected dependencies, because once resources will be destroyed, any commands on dependent units will fail with missing dependencies. For example, if <code>destroy</code> was called on the <code>redis</code> unit, you will be asked to confirm the action because <code>backend-app</code> depends on <code>redis</code>. You can avoid the prompt by using <code>--non-interactive</code>.</p>

<h3>Testing multiple units locally</h3>

<p>If you are using Terragrunt to configure <a href="{{site.baseurl}}/docs/features/keep-your-terraform-code-dry/#remote-terraform-configurations">remote OpenTofu/Terraform configurations</a> and all of your units have the <code>source</code> parameter set to a Git URL, but you want to test with a local checkout of the code, you can use the <code>--source</code> parameter:</p>

<p><code>bash
cd root
terragrunt run-all plan --source /source/modules
</code></p>

<p>If you set the <code>--source</code> parameter, the <code>run-all</code> commands will assume that parameter is pointing to a folder on your local file system that has a local checkout of all of your OpenTofu/Terraform modules. For each unit that is being processed via a <code>run-all</code> command, Terragrunt will read in the <code>source</code> parameter in that unit’s <code>terragrunt.hcl</code> file, parse out the path (the portion after the double-slash), and append the path to the <code>--source</code> parameter to create the final local path for that unit.</p>

<p>For example, consider the following <code>terragrunt.hcl</code> file:</p>

<p><code>hcl
terraform {
  source = "git::git@github.com:acme/infrastructure-modules.git//networking/vpc?ref=v0.0.1"
}
</code></p>

<p>If you run <code>terragrunt run-all apply --source /source/infrastructure-modules</code>, then the local path Terragrunt will compute for the module above will be <code>/source/infrastructure-modules//networking/vpc</code>.</p>

<h3>Limiting the unit execution parallelism</h3>

<p>By default Terragrunt will not impose a limit on the number of units it executes when it traverses the dependency graph,
meaning that if it finds 5 units it'll run OpenTofu/Terraform 5 times in parallel once in each unit. Sometimes
this might create a problem if there are a lot of units in the dependency graph like hitting a rate limit on some
cloud provider.</p>

<p>To limit the maximum number of unit executions at any given time use the <code>--parallelism [number]</code> flag</p>

<p><code>sh
terragrunt run-all apply --parallelism 4
</code></p>

<h3>Saving OpenTofu/Terraform plan output</h3>

<p>Terragrunt enables you to save the execution plan to a designated directory in binary or JSON format, which is helpful for reviewing and reusing the plan at a later time.
To save the plan, use the <code>--out-dir</code> flag (or <code>TG_OUT_DIR</code> environment variable) as demonstrated below:</p>

<p><code>sh
$ terragrunt run-all plan --out-dir /tmp/tfplan
$ tree /tmp/tfplan
/tmp/tfplan
├── app1
│   └── tfplan.tfplan
├── app2
│   └── tfplan.tfplan
├── app3
│   └── tfplan.tfplan
└── project-2
    └── project-2-app1
        └── tfplan.tfplan
$ terragrunt run-all apply --out-dir /tmp/tfplan
</code></p>

<p>For planning a destroy operation, use the following commands:</p>

<p><code>sh
terragrunt run-all plan -destroy --out-dir /tmp/tfplan
terragrunt run-all apply --out-dir /tmp/tfplan
</code></p>

<p>To save plan in json format use <code>--json-out-dir</code> flag (or <code>TG_JSON_OUT_DIR</code> environment variable):</p>

<p>```sh
$ terragrunt run-all plan --json-out-dir /tmp/json
$ tree /tmp/json
/tmp/json
├── app1
│   └── tfplan.json
├── app2
│   └── tfplan.json
├── app3
│   └── tfplan.json
└── project-2
    └── project-2-app1
        └── tfplan.json</p>

<h1>combine binary and json plans</h1>

<p>$ terragrunt run-all plan --out-dir /tmp/all --json-out-dir /tmp/all
$ tree /tmp/all
/tmp/all
├── app1
│   ├── tfplan.json
│   └── tfplan.tfplan
├── app2
│   ├── tfplan.json
│   └── tfplan.tfplan
├── app3
│   ├── tfplan.json
│   └── tfplan.tfplan
└── project-2
    └── project-2-app1
        ├── tfplan.json
        └── tfplan.tfplan
```</p>

<p>Notes:</p>

<ul>
<li>The plan for each unit will be saved the same hierarchy as the unit structure.</li>
<li>The file name for the plans are <code>tfplan.tfplan</code> for the plan binary and <code>tfplan.json</code> for the plan JSON.</li>
<li>JSON plan files can't be used with <code>terragrunt run-all apply</code> command, only binary plan files can be used.</li>
<li>Output directories can be combined which will lead to saving both binary and JSON plans.</li>
</ul>

</body>
</html>
