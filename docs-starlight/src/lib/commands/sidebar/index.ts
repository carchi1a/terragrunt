import type { CollectionEntry } from "astro:content";
import type { SidebarItem } from "node_modules/@astrojs/starlight/schemas/sidebar";
import fs from 'node:fs';
import path from 'node:path';
import matter from 'gray-matter';
import { sidebar as sidebarTemplate } from '../../../../astro.config.mjs';

export async function getSidebar(commands: CollectionEntry<'commands'>[]): Promise<SidebarItem[]> {
  // Deep clone the sidebar template to avoid mutations
  const sidebar = JSON.parse(JSON.stringify(sidebarTemplate));

  // Build the commands sidebar items
  const commandItems = commands.map((command) => {
    const data = command.data;
    const sidebarItem = {
      label: data.name,
      link: `/docs/reference/cli/commands/${data.path}`,
    } as SidebarItem;

    if (data.experiment) {
      sidebarItem.badge = {
        variant: 'tip',
        text: 'exp',
      };
    }

    return sidebarItem;
  });

  // Find the Reference section
  const referenceSection = sidebar.find(item =>
    typeof item === 'object' && 'label' in item && item.label === 'Reference'
  ) as { items: SidebarItem[] };

  if (referenceSection && 'items' in referenceSection) {
    // Find the CLI section
    const cliSection = referenceSection.items.find(item =>
      typeof item === 'object' && 'label' in item && item.label === 'CLI'
    ) as { items: SidebarItem[] };

    if (cliSection && 'items' in cliSection) {
      // Insert the commands group after the Overview item
      const overviewIndex = cliSection.items.findIndex(item =>
        typeof item === 'object' && 'label' in item && item.label === 'Overview'
      );

      if (overviewIndex !== -1) {
        cliSection.items.splice(overviewIndex + 1, 0, {
          label: 'Commands',
          collapsed: true,
          items: commandItems
        });
      }
    }
  }

  // For sections with autogenerate, populate them from the filesystem
  populateAutogeneratedSections(sidebar);

  return sidebar;
}

function populateAutogeneratedSections(items: SidebarItem[]) {
  for (const item of items) {
    if (typeof item === 'object' && 'autogenerate' in item) {
      const dirPath = path.join(process.cwd(), 'src/content/docs', item.autogenerate.directory);
      if (fs.existsSync(dirPath)) {
        const files = fs.readdirSync(dirPath)
          .filter(file => file.endsWith('.mdx') || file.endsWith('.md'));

        item.items = files.map(file => {
          const content = fs.readFileSync(path.join(dirPath, file), 'utf-8');
          const { data } = matter(content);
          return {
            label: data.title,
            slug: data.slug,
            order: data.sidebar?.order
          };
        }).sort((a, b) => (a.order || 99) - (b.order || 99));

        delete item.autogenerate;
      }
    }

    // Recursively handle nested items
    if (typeof item === 'object' && 'items' in item) {
      populateAutogeneratedSections(item.items);
    }
  }
}
