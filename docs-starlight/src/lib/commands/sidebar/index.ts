import type { CollectionEntry } from "astro:content";
import type { SidebarItem } from "node_modules/@astrojs/starlight/schemas/sidebar";
import fs from 'node:fs';
import path from 'node:path';
import matter from 'gray-matter';
import { sidebar as sidebarTemplate } from '../../../../astro.config.mjs';

export async function getSidebar(commands: CollectionEntry<'commands'>[]): Promise<SidebarItem[]> {
  // Deep clone the sidebar template to avoid mutations
  const sidebar: SidebarItem[] = JSON.parse(JSON.stringify(sidebarTemplate));

  commands.sort((a, b) => a.data.sidebar.order - b.data.sidebar.order);

  // First, create all command items
  const flatCommandItems = commands.map((command) => {
    const data = command.data;
    const sidebarItem = {
      label: data.name,
      link: `/docs/reference/cli/commands/${data.path}`,
    } as SidebarItem;

    if (data.experiment) {
      sidebarItem.badge = {
        variant: 'tip',
        text: 'exp',
      };
    }

    // Add the path to help with nesting
    (sidebarItem as any).originalPath = data.path;

    return sidebarItem;
  });

// Then, organize them into a nested structure
const commandItems: SidebarItem[] = [];
const groupedCommands: Record<string, SidebarItem[]> = {};

flatCommandItems.forEach((item) => {
  const path = (item as any).originalPath;
  const parts = path.split('/');

  // If this is a root-level command (no slashes)
  if (parts.length === 1) {
	delete (item as any).originalPath;
	commandItems.push(item);
  }
  // If this is a nested command
  else {
	const groupName = parts[0];
	if (!groupedCommands[groupName]) {
	  groupedCommands[groupName] = [];
	  // Add the group to the main commands array
	  commandItems.push({
		label: groupName,
		collapsed: true,
		items: groupedCommands[groupName]
	  });
	}
	delete (item as any).originalPath;
	groupedCommands[groupName].push(item);
  }
});

  // Find the Reference section
  const referenceSection = sidebar.find(item =>
    typeof item === 'object' && 'label' in item && item.label === 'Reference'
  ) as { items: SidebarItem[] };

  if (referenceSection && 'items' in referenceSection) {
    // Find the CLI section
    const cliSection = referenceSection.items.find(item =>
      typeof item === 'object' && 'label' in item && item.label === 'CLI'
    ) as { items: SidebarItem[] };

    if (cliSection && 'items' in cliSection) {
      // Remove the existing autogenerated Commands section if it exists
      cliSection.items = cliSection.items.filter(item =>
        !(typeof item === 'object' && 'label' in item && item.label === 'Commands')
      );

      // Insert the commands group after the Overview item
      const overviewIndex = cliSection.items.findIndex(item =>
        typeof item === 'object' && 'label' in item && item.label === 'Overview'
      );

      if (overviewIndex !== -1) {
        cliSection.items.splice(overviewIndex + 1, 0, {
          label: 'Commands',
          collapsed: true,
          items: commandItems
        } as SidebarItem);
      }
    }
  }

  // For sections with autogenerate, populate them from the filesystem
  populateAutogeneratedSections(sidebar);

  return sidebar;
}

function populateAutogeneratedSections(items: SidebarItem[]) {
  for (const item of items) {
    if (typeof item === 'object' && 'autogenerate' in item) {
      const dirPath = path.join(process.cwd(), 'src/content/docs', item.autogenerate.directory);
      if (fs.existsSync(dirPath)) {
        const files = fs.readdirSync(dirPath)
          .filter(file => file.endsWith('.mdx') || file.endsWith('.md'));

        item.items = files.map(file => {
          const content = fs.readFileSync(path.join(dirPath, file), 'utf-8');
          const { data } = matter(content);
          return {
            label: data.title,
            slug: data.slug,
            order: data.sidebar?.order
          };
        }).sort((a, b) => (a.order || 99) - (b.order || 99));

        delete item.autogenerate;
      }
    }

    // Recursively handle nested items
    if (typeof item === 'object' && 'items' in item) {
      populateAutogeneratedSections(item.items);
    }
  }
}
